local dataAuth = require(game.ServerScriptService.DataAuth)
if dataAuth.checkAuth() == true then
	----- Game Objects -----
	local TweenService = game:GetService("TweenService")
	local repS = game:GetService("ReplicatedStorage")
	local sss = game:GetService("ServerScriptService")
	local ss = game:GetService("ServerStorage")
	local MarketPlaceService = game:GetService("MarketplaceService")
	local petsFolder = game.Workspace.ActivePets
	local tSpawns = game.Workspace.TreasureSpawns
	local gItems = game.ServerStorage.GeneralItems
	local treasure = gItems.Mud

	----- Pet Definitons -----
	local plrDict = {}
	local plrDebounces = {}
	local tot = 6

	----- Variables -----
	local serverWL = {}
	local treasureLookAt = {}
	local spawnRate = 5 --> Mud Spawn Rate
	local clickDist = 60
	local treasureChance = {
		{"Coin1",0,0.3,80,0.05}, --> 30% Spawn Rate, 5% Max Reward
		{"Coin2",0.3,0.475,100,0.1}, --> 17.5% Spawn Rate, 10% Max Reward
		{"Ingot",0.475,0.625,120,0.125}, --> 15% Spawn Rate, 12.5% Max Reward
		{"SmallSack",0.625,0.77,150,0.15}, --> 14.5% Spawn Rate, 15% Max Reward
		{"BigSack",0.77,0.87,200,0.2}, --> 10% Spawn Rate, 20% Max Reward
		{"Barrel",0.87,0.945,250,0.3}, --> 7.5% Spawn Rate, 30% Max Reward
		{"MediumChest",0.945,0.995,350,0.45}, --> 5% Spawn Rate, 45% Max Reward
		{"BigChest",0.995,1,500,1} --> 0.5% Spawn Rate, 100% Max Reward
	}

	----- Remotes -----
	local digR = repS.Remotes.Dig_Event
	local pet_add_remove = repS.Remotes:FindFirstChild("Pet_Add_Remove")
	local petStats = repS.Remotes.Pet_Stats
	local rewStats = repS.Remotes.Rew_Data

	game:GetService("Players").PlayerRemoving:Connect(function(player)
		local plrName = player.Name
		if serverWL[plrName] ~= nil then
			serverWL[plrName]:Destroy()
		end
		if treasureLookAt[plrName] ~= nil then
			treasureLookAt[plrName] = nil
		end
		if plrDict[plrName] ~= nil then
			for i,v in pairs(plrDict[plrName]) do
				if v[3] ~= "" then
					removePet(v[3])
				end
			end
			plrDict[plrName] = nil
		end	
		if plrDebounces[plrName] ~= nil then
			plrDebounces[plrName] = nil
		end
	end)

	spawn(function()
		while true do
			for _,zone in pairs(tSpawns:GetChildren()) do
				for _,spawner in pairs(zone:GetChildren()) do
					if spawner:FindFirstChild("Mud") == nil then
						spawnTreasure(spawner,tonumber(string.sub(zone.Name,5)))
						break
					end
				end
			end
			wait(spawnRate)
		end
	end)

	petStats.OnServerInvoke = function(player,cmd)
		if cmd == "petDamage" then
			local petConfig = getEquippedPetConfig(player.Name)
			local totalDmg = 0
			for i,v in pairs(petConfig[2]) do
				totalDmg += v
			end
			return totalDmg
		end
	end

	rewStats.OnServerInvoke = function(player,cmd)
		if cmd == "getRewardNormal" then
			local reward = rewardEquation("BigChest",_G.dataUpdMod.manipulateData(player,"Get","Level"),1)[1]*7.5
			reward = math.floor(reward*_G.dataUpdMod.manipulateData(player,"Get","CoinMultiple"))
			_G.dataUpdMod.manipulateData(player,"Increment","Gold",reward)
			return reward
		elseif cmd == "getRewardGroup" then
			local reward = rewardEquation("BigChest",_G.dataUpdMod.manipulateData(player,"Get","Level"),1)[1]*15
			reward = math.floor(reward*_G.dataUpdMod.manipulateData(player,"Get","CoinMultiple"))
			_G.dataUpdMod.manipulateData(player,"Increment","Gold",reward)
			return reward
		end
	end

	function rewardEquation(rewType,lvl,zoneNum)
		local config = {}
		for _,v in pairs(treasureChance) do
			if v[1] == rewType then
				local goldReward = math.floor((-(0.08246*(lvl*lvl))+(512.4*lvl)-412.3)*v[5]*zoneNum*zoneNum*zoneNum)
				table.insert(config, goldReward)
				table.insert(config, v[4]*(lvl/8))
				return config
			end
		end
	end

	function getAnglesDict()
		local angles = {}
		for i = 1,100 do
			table.insert(angles,{60*i,false,""})
		end
		return angles
	end

	function spawnTreasure(spawner,zoneNum)
		local t = treasure:Clone()
		local hp = Instance.new("IntValue")
		local rew = Instance.new("StringValue")
		hp.Parent = t
		rew.Parent = t
		local rand = math.random()
		for _,v in pairs(treasureChance) do
			if rand >= v[2] and rand < v[3] then
				rew.Value = v[1]
				hp.Value = zoneNum*zoneNum*zoneNum*zoneNum*zoneNum*zoneNum*(v[4]/2)
				break
			end
		end
		local cd = Instance.new("ClickDetector")
		cd.Parent = t.MudPart.ClickPart
		cd.MaxActivationDistance = clickDist
		cd.MouseClick:Connect(function(player)
			if plrDebounces[player.Name] == nil then
				plrDebounces[player.Name] = true
			end
			if plrDebounces[player.Name] == true then
				plrDebounces[player.Name] = false
				spawn(function()
					wait(0.5)
					plrDebounces[player.Name] = true
				end)
				if not t.Whitelist:FindFirstChild(player.Name) then
					local wl = t.Whitelist
					local st = Instance.new("StringValue")
					st.Parent = wl
					st.Value = player.Name
					st.Name = player.Name
					if serverWL[player.Name] ~= nil then
						serverWL[player.Name]:Destroy()
						digR:FireClient(player,"StopDigging")
						treasureLookAt[player.Name] = nil
						if player.Character ~= nil and player.Character.Humanoid.Health ~= 0 then
							shovelBackPos(player.Character:FindFirstChild("Shovel"),player.Character)
						end
					end
					serverWL[player.Name] = st
					local multp
					local multp2
					repeat
						wait()
						multp = math.random(-1,1)
					until multp ~= 0
					repeat
						wait()
						multp2 = math.random(-1,1)
					until multp2 ~= 0
					
					local posNum = math.random(1.2,3.3)
					local posNum2 = math.random(1.2,3.3)
					local cf = CFrame.new(t.MudPart.Position) * CFrame.new(posNum*multp,0,posNum2*multp2)
					digR:FireClient(player,"StartProcess",t.MudPart,zoneNum)
					treasureLookAt[player.Name] = nil
					wait(0.1)
					treasureLookAt[player.Name] = t.MudPart
					if getEquippedPetConfig(player.Name)[1] > 0 then
						spawn(function()
							petsDamage(player.Name)
						end)
					end
					if player.Character ~= nil and player.Character.Humanoid.Health ~= 0 then
						moveTo(player.Character.Humanoid,cf.Position)
					end
				end
			end
		end)
		t.Parent = spawner
		t:SetPrimaryPartCFrame(spawner.CFrame)
	end

	digR.OnServerEvent:Connect(function(plr,cmd,treasureModel,damageAmount)
		if serverWL[plr.Name] then
			if cmd == "Stop" then
				serverWL[plr.Name]:Destroy()
				if plr.Character ~= nil and plr.Character.Humanoid.Health ~= 0 then
					shovelBackPos(plr.Character:FindFirstChild("Shovel"),plr.Character)
				end
				treasureLookAt[plr.Name] = nil
			elseif cmd == "Damage" then
				if treasureModel ~= nil then
					local tempHp = treasureModel:FindFirstChildWhichIsA("IntValue")
					if tempHp ~= nil then
						if tempHp.Value - damageAmount > 0 then
							tempHp.Value -= damageAmount
						else
							digR:FireClient(plr,"StopDigging")
							treasureLookAt[plr.Name] = nil
							if plr.Character ~= nil and plr.Character.Humanoid.Health ~= 0 then
								shovelBackPos(plr.Character:FindFirstChild("Shovel"),plr.Character)
							end
							spawn(function()
								wait(0.7)
								digR:FireClient(plr,"DestroyGUI",treasureModel)
							end)
							
							if serverWL[plr.Name] and treasureModel:FindFirstChild("Alive") then
								treasureModel:FindFirstChild("Alive"):Destroy()
								tempHp.Value = 0
								local currentRew = treasureModel:FindFirstChildWhichIsA("StringValue").Value
								local rewItem = game:GetService("ServerStorage").Treasures:FindFirstChild(currentRew)
								for _,st in pairs(treasureModel.Whitelist:GetChildren()) do
									for i,v in pairs(serverWL) do
										if v == st then
											serverWL[i]:Destroy()
											if game.Players:FindFirstChild(i) then
												local newPlr = game.Players:FindFirstChild(i)
												local rewEq = rewardEquation(currentRew,_G.dataUpdMod.manipulateData(newPlr,"Get","Level"),tonumber(string.sub(treasureModel.Parent.Parent.Name,5,5)))
												local goldBoost = getEquippedPetConfig(i)[3]
												local goldTotal = math.floor((rewEq[1]+goldBoost)*_G.dataUpdMod.manipulateData(newPlr,"Get","CoinMultiple"))
												local expTotal = math.floor(rewEq[2]*_G.dataUpdMod.manipulateData(newPlr,"Get","CoinMultiple"))
												_G.dataUpdMod.manipulateData(newPlr,"Increment","Gold",goldTotal)
												_G.dataUpdMod.manipulateData(newPlr,"Increment","Experience",expTotal)
												_G.dataUpdMod.manipulateData(newPlr,"Increment","MatsCollected",1)
											end
										end
									end
								end
								if treasureModel:FindFirstChildWhichIsA("StringValue") then
									for _,v in pairs(treasureModel:GetDescendants()) do
										if v.Name ~= "MudPart" and not v:IsA("IntValue") then
											v:Destroy()
										end
									end
									local rcl = rewItem:Clone()
									spawn(function()
										for i = 1,10 do
											wait(0.07)
											treasureModel.MudPart.Transparency += 0.1
										end
									end)
									if rcl:IsA("Model") then
										rcl:SetPrimaryPartCFrame(treasureModel.MudPart.CFrame)
										rcl.Parent = treasureModel
										if rcl then
											for i = 1,40 do
												wait()
												if rcl.PrimaryPart ~= nil then
													rcl:SetPrimaryPartCFrame(rcl.PrimaryPart.CFrame*CFrame.new(0,0.08,0))
												else
													break
												end
											end
											if rcl then
												for _,v in pairs(rcl:GetChildren()) do
													spawn(function()
														for i = 1,10 do
															wait()
															if v then
																v.Transparency += 0.1
															else
																break
															end
														end
													end)
												end
											end
										end
									else
										rcl.CFrame = treasureModel.MudPart.CFrame
										rcl.Parent = treasureModel
										for i = 1,40 do
											wait()
											rcl.CFrame = rcl.CFrame*CFrame.new(0,0.08	,0)
										end
										for i = 1,10 do
											wait()
											rcl.Transparency += 0.1
										end
									end
									wait(0.5)
									treasureModel:Destroy()
								end
							end
						end
					end
				end
			end
		end
	end)

	function moveTo(humanoid,targetPoint)
		local targetReached = false
		local connection
		if humanoid ~= nil and humanoid.Health ~= 0 then
			connection = humanoid.MoveToFinished:Connect(function(reached)
				targetReached = true
				connection:Disconnect()
				connection = nil
				local hrp
				local name
				if humanoid ~= nil and humanoid.Parent ~= nil then
					hrp = humanoid.Parent.HumanoidRootPart
					name = humanoid.Parent.Name
				end
				if treasureLookAt[name] and hrp ~= nil then
					hrp.CFrame = CFrame.new(hrp.Position,Vector3.new(treasureLookAt[name].Position.X,hrp.Position.Y,treasureLookAt[name].Position.Z))
					digTreasure(treasureLookAt[name],humanoid.Parent)
				end
			end)
			humanoid:MoveTo(targetPoint)
		end
		spawn(function()
			while not targetReached and humanoid ~= nil and humanoid.Parent ~= nil and treasureLookAt[humanoid.Parent.Name] ~= nil do
				if not (humanoid and humanoid.Parent) then
					break
				end
				if humanoid.WalkToPoint ~= targetPoint then
					break
				end
				humanoid:MoveTo(targetPoint)
				wait(6)
			end
			if connection then
				connection:Disconnect()
				connection = nil
			end
		end)
	end

	function digTreasure(t,char)
		shovelDigPos(char:FindFirstChild("Shovel"),char)
		digR:FireClient(game.Players:GetPlayerFromCharacter(char),"StartDigging")
	end

	function shovelDigPos(shovel,char)
		if shovel ~= nil and char.UpperTorso:FindFirstChild("ShovelWeld") then
			char.UpperTorso:FindFirstChild("ShovelWeld"):Destroy()
			shovel:SetPrimaryPartCFrame(char.RightHand.CFrame*CFrame.new(0,0,-0.5)*CFrame.Angles(math.rad(90),0,0))
			local wc = Instance.new("WeldConstraint")
			wc.Parent = char.RightHand
			wc.Part0 = char.RightHand
			wc.Part1 = shovel.PrimaryPart
			wc.Name = "ShovelWeld"
			shovel.Parent = char
		end
	end

	function shovelBackPos(shovel,char)
		if shovel ~= nil and char.RightHand:FindFirstChild("ShovelWeld") then
			char.RightHand:FindFirstChild("ShovelWeld"):Destroy()
			if string.find(shovel.Name,"Crystalline") then
				shovel:SetPrimaryPartCFrame(char.UpperTorso.CFrame*CFrame.new(0.4,0.4,0.75)*CFrame.Angles(0,math.rad(180),math.rad(45)))
			else
				shovel:SetPrimaryPartCFrame(char.UpperTorso.CFrame*CFrame.new(0.7,0.7,0.65)*CFrame.Angles(0,math.rad(180),math.rad(45)))
			end
			local wc = Instance.new("WeldConstraint")
			wc.Parent = char.UpperTorso
			wc.Part0 = char.UpperTorso
			wc.Part1 = shovel.PrimaryPart
			wc.Name = "ShovelWeld"
			shovel.Parent = char
		end
	end

	spawn(function()
		while true do
			local x = TweenService:Create(ss.HoverPos, TweenInfo.new(2,Enum.EasingStyle.Sine,Enum.EasingDirection.Out), {Value = Vector3.new(0, 0.5, 0)})
			x:Play()
			wait(2)
			x = TweenService:Create(ss.HoverPos, TweenInfo.new(2,Enum.EasingStyle.Sine,Enum.EasingDirection.Out), {Value = Vector3.new(0, -0.5, 0)})
			x:Play()
			wait(2)
		end
	end)

	spawn(function()
		while true do
			local x = TweenService:Create(ss.DigPos, TweenInfo.new(0.2,Enum.EasingStyle.Bounce,Enum.EasingDirection.Out), {Value = Vector3.new(0, 0.2, 0)})
			x:Play()
			wait(0.2)
			x = TweenService:Create(ss.DigPos, TweenInfo.new(0.2,Enum.EasingStyle.Bounce,Enum.EasingDirection.Out), {Value = Vector3.new(0, -2, 0)})
			x:Play()
			wait(0.2)
		end
	end)

	function weldMdl(mdl)
		local pp = mdl.PrimaryPart
		for _,v in pairs(mdl:GetChildren()) do
			if v ~= pp and not v:IsA("StringValue") and not v:IsA("IntValue") then
				local wc = Instance.new("WeldConstraint")
				wc.Parent = pp
				wc.Part0 = pp
				wc.Part1 = v
			end
		end
	end

	function equipPet(char,petId,petName,tempDeg,petDmg,petBoost)
		local cl = game:GetService("ServerStorage").Pets:FindFirstChild(petName,true):Clone()
		
		local namVal = Instance.new("StringValue")
		namVal.Value = cl.Name
		namVal.Name = "PetName"
		namVal.Parent = cl
		local dmgVal = Instance.new("IntValue")
		dmgVal.Value = petDmg
		dmgVal.Name = "Dmg"
		dmgVal.Parent = cl
		local boostVal = Instance.new("IntValue")
		boostVal.Value = petBoost
		boostVal.Name = "Boost"
		boostVal.Parent = cl
		
		cl.Name = petId
		local bp = Instance.new("BodyPosition")
		local bg = Instance.new("BodyGyro")
		bg.MaxTorque = Vector3.new(1000,1000,1000)
		bg.P = 1200
		bg.D = 400
		weldMdl(cl)
		cl:SetPrimaryPartCFrame(char:WaitForChild("HumanoidRootPart").CFrame)
		cl.Parent = petsFolder
		bp.Parent = cl.PrimaryPart
		bg.Parent = cl.PrimaryPart
		spawn(function()
			petMovement(cl,char.Name,tempDeg)
		end)
	end

	function removePet(petId)
		if(petsFolder:FindFirstChild(petId)) then
			petsFolder:FindFirstChild(petId):Destroy()
		end
	end

	pet_add_remove.OnServerEvent:Connect(function(player,action,petId,petName,petDmg,petBoost)
		if action == "Add" then
			local tempDeg = 60
			if plrDict[player.Name] == nil then
				plrDict[player.Name] = getAnglesDict()
				plrDict[player.Name][1] = {60,true,petId}
			else
				for i,v in pairs(plrDict[player.Name]) do
					if v[2] == false then
						v[2] = true
						v[3] = petId
						tempDeg = v[1]
						break
					end
				end
			end
			if player.Character ~= nil and player.Character.Humanoid.Health ~= 0 then
				equipPet(player.Character,petId,petName,tempDeg,petDmg,petBoost)
			end
		elseif action == "Remove" then
			for i,v in pairs(plrDict[player.Name]) do
				if v[3] == petId then
					v[2] = false
					v[3] = ""
					break
				end
			end		
			removePet(petId)		
		end
	end)

	function petMovement(pet,plrName,tempDeg)
		if pet ~= nil and pet.PrimaryPart ~= nil then
			local bp = pet.PrimaryPart.BodyPosition
			local bg = pet.PrimaryPart.BodyGyro
			while pet.Parent ~= nil do
				wait()
				local hrp
				if game.Workspace:FindFirstChild(plrName) then
					hrp = game.Workspace:FindFirstChild(plrName):FindFirstChild("HumanoidRootPart")
				end
				if bg.Parent ~= nil and hrp ~= nil then
					if treasureLookAt[plrName] ~= nil then
						bp.P = 13000
						if hrp ~= nil then
							local changedPos = CFrame.new(treasureLookAt[plrName].Position.X,hrp.Position.Y,treasureLookAt[plrName].Position.Z)*CFrame.new(tot*0.75*math.sin(tempDeg),0,tot*0.75*math.cos(tempDeg))
							bg.CFrame = CFrame.new(bg.Parent.Position,Vector3.new(treasureLookAt[plrName].CFrame.Position.X,math.rad(60),treasureLookAt[plrName].CFrame.Position.Z))
							bp.Position = changedPos.Position + ss.DigPos.Value + Vector3.new(0,1,0)
						end
					else
						bp.P = 10000
						if hrp ~= nil then
							local changedPos = CFrame.new(hrp.CFrame.Position)*CFrame.new(tot*math.sin(tempDeg),0,tot*math.cos(tempDeg))
							bg.CFrame = CFrame.new(bg.Parent.Position,Vector3.new(hrp.CFrame.Position.X,bg.Parent.Position.Y,hrp.CFrame.Position.Z))
							bp.Position = changedPos.Position + ss.HoverPos.Value + Vector3.new(0,1,0)
						end
					end
				end
			end
		end
	end

	function petsDamage(plrName)
		if treasureLookAt[plrName] ~= nil then
			while treasureLookAt[plrName] ~= nil do
				local dmgConfig = specificallyForDamage(plrName)
				if #dmgConfig[2] == 0 then
					break
				else
					----- Static Damage -----
					local totalDmg = 0
					for i,v in pairs(dmgConfig[2]) do
						totalDmg += v
					end
					local wTimes = 33
					if MarketPlaceService:UserOwnsGamePassAsync(game:GetService("Players"):GetUserIdFromNameAsync(plrName),13099081) then
						wTimes = 17
					end
					for i = 1,wTimes do
						wait()
						if treasureLookAt[plrName] == nil then
							break
						end
					end
					
					if treasureLookAt[plrName] ~= nil then
						if game:GetService("Players"):FindFirstChild(plrName) then
							digR:FireClient(game:GetService("Players"):FindFirstChild(plrName),"PetDigging",totalDmg)
						else
							break
						end
					else
						break
					end
					
					----- Incremental Damage -----
					--[[ for i,v in pairs(dmgConfig[2]) do
						wait(1/dmgConfig[1])
						if treasureLookAt[plrName] ~= nil then
							print(dmgConfig[2][i])
							if game:GetService("Players"):FindFirstChild(plrName) then
								digR:FireClient(game:GetService("Players"):FindFirstChild(plrName),"PetDigging",dmgConfig[2][i])
							else
								return
							end
						else
							return
						end
					end--]]
				end
			end
		end
	end

	function getEquippedPetConfig(plrName)
		local num = 0
		local totalBoost = 0
		local config = {}
		if plrDict[plrName] then
			for i,v in pairs(plrDict[plrName]) do
				if v[3] ~= "" then
					num+=1
					table.insert(config,petsFolder:FindFirstChild(v[3]).Dmg.Value)
					totalBoost+=petsFolder:FindFirstChild(v[3]).Boost.Value
				end
			end
		end
		return {num,config,totalBoost}
	end

	function specificallyForDamage(plrName)
		local num = 0
		local totalBoost = 0
		local config = {}
		if plrDict[plrName] then
			for i,v in pairs(plrDict[plrName]) do
				if v[3] ~= "" then
					num+=1
					table.insert(config,petsFolder:FindFirstChild(v[3]).Dmg.Value)
					totalBoost+=petsFolder:FindFirstChild(v[3]).Boost.Value
				end
			end
		end
		return {num,config,totalBoost}
	end
end
